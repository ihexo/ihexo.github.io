[{"title":"[译]Kotlin 1.1.2 is out","date":"2017-04-25T13:19:00.000Z","path":"2017/04/25/Kotlin 1.1.2 is out/","text":"我们很高兴宣布Kotlin 1.1.2正式发布了，这也是Kotlin 1.1的第二次 Bug 修复和工具更新。此次更新不仅提升了编译器和 IntelliJ IDEA 插件的性能，同时也在工具中增加了新的特性，当然还有各方面的问题修复。 此外，Kotlin 1.1.2也提升了与Android Gradle插件版本2.4.0-alpha的兼容性。本次发布版本的所有更新可在更新日志中查看。在这里要感谢所有外部的贡献者，他们提交的pull request也包含于该版本中：Yoshinori Isogai，Jonathan Leitschuh和Kirill Rakhman 。感谢所有尝试EAP构建并向我们发送反馈意见的人！ 迁移说明Kotlin编译器现在也需要基于JDK 8运行。但您应该不需要在意这一点改变，因为大多数其他Java开发工具（比如Gradle和Android工具）也需要JDK 8，因此您肯定已经安装了JDK 8。对于由编译器生成的代码，仍然默认兼容Java 1.6，而且我们也没有计划要放弃对生成的Java 1.6兼容性字节码的支持。 内部类当中不能再声明 object，因为这个 object 将能够访问外部类的实例，我们知道 object 始终是一个单例，因此这在理论上是行不通的。同样的，内部密封类也是不被允许的。然而这只是临时方案，在我们添加了在其外部类而非内部类中声明内部密封类的子类的可能性时，将会删除该限制。(KT-16232，KT-16233） 现在使用一个名称完全由下划线字符组成的声明时将必须使用反引号。(KT-16264） Maven增量编译从Kotlin 1.1.2开始，以前用于IntelliJ IDEA和Gradle构建的增量编译现在也支持Maven。启用该功能时，需要使用-D命令行参数或proterties标记设置kotlin.compiler.incremental属性为true： 123&lt;properties&gt; &lt;kotlin.compiler.incremental&gt;true&lt;/kotlin.compiler.incremental&gt;&lt;/properties&gt; Maven注解处理现在可以从Maven构建中调用Kotlin的注解处理工具kapt了，只需要在compile前，从kotlin-maven-plugin中添加kapt的执行目标： 1234567891011121314151617181920&lt;execution&gt; &lt;id&gt;kapt&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;kapt&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sourceDirs&gt; &lt;sourceDir&gt;src/main/kotlin&lt;/sourceDir&gt; &lt;sourceDir&gt;src/main/java&lt;/sourceDir&gt; &lt;/sourceDirs&gt; &lt;annotationProcessorPaths&gt; &lt;!-- Specify your annotation processors here. --&gt; &lt;annotationProcessorPath&gt; &lt;groupId&gt;com.google.dagger&lt;/groupId&gt; &lt;artifactId&gt;dagger-compiler&lt;/artifactId&gt; &lt;version&gt;2.9&lt;/version&gt; &lt;/annotationProcessorPath&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt;&lt;/execution&gt; 在这里查看具有Java-Kotlin代码支持和测试的POM文件完整示例。 请注意，IntelliJ IDEA自己的构建系统仍然不支持kapt。当您要重新运行注解处理时，需要从“Maven Projects”工具栏中启动构建。 内联方法重构我们终于在Kotlin代码中实现了Inline方法（Function）的支持。 其他IDE改进在1.1.x时间范围内，我们很大一部分的工作是致力于提高IntelliJ IDEA插件的性能。在此次发布的1.1.2版本中，我们对几项主要性能进行了改进，主要涉及输入响应，同时我们也已经为后续1.1.3版本进行了额外的重大改进。 除此之外，我们还在此版本中进行了大量新的检测，快速解决方案和小型IDE功能。特别值得一提的是，在编辑器中支持折叠Android String资源引用，以及新的用于处理Android API版本问题的问题解决方案。 如何更新要更新IDEA插件，在菜单栏中依次选择 Tools | Kotlin | Configure Kotlin Plugin Update，然后点击“Check for updates now”按钮。另外，不要忘记在Maven和Gradle构建脚本中更新编译器和标准库版本 命令行编译器可以从 Github发布页面 页面下载。像往常一样，如果您在新版本中遇到任何问题，您可以在 论坛 中寻求帮助，在Slack(获取邀请)、或者在问题追踪器提出问题 。让我们来吧！","tags":[]},{"title":"[译]Kotlin 1.1 Event Report","date":"2017-04-06T15:21:00.000Z","path":"2017/04/06/Kotlin 1.1 Event Report/","text":"Kotlin 1.1 版本发布在社区反响很好。为了演示 Kotlin 1.1 的新功能，JetBrains 提供了一个在线活动。所有感兴趣的人都可以观看 Andrey Breslav 的在线直播演示，并在 Q&amp;A 环节获得他们关心的问题的答案。这激发了许多当地社区组织见面会：超过 30 个用户组在 21 个国家举办了线下活动。你可以在这里找到完整的活动列表 Kotlin社区网页 。活动当天有 3000 多人参加了线上直播。演示和 Q&amp;A 视频可以在 YouTube 上查看： Kotlin 1.1 活动反馈如果你看了直播，我们想知道你的想法！请 填写此表格 分享您的反馈。它只需要大约7-10分钟。您的投入对于帮助我们改进未来的 Kotlin 活动非常重要。 Kotlin 未来特性调查 我们还向所有社区提供了对 Kotlin 未来的影响。活动组织者收到了调查表，活动参与者可以在线下对最期望的功能发表看法。调查得到很多关注，我们现在已经把它放在网上，以听取更广泛的社区建议。现在你可以在线给 Kotlin 的未来提供你的建议 ！请注意，你在 v1.2 中有很大可能看不到这些功能，但我们会在确定工作优先级时考虑您的意见。","tags":[]},{"title":"[译]Kotlin 1.1 也适用于 Android 开发者","date":"2017-04-05T08:13:00.000Z","path":"2017/04/05/Kotlin 1.1 is also for Android Developers/","text":"Kotlin 1.1的发布令人们感到非常兴奋。此版本包含的新功能对 Java 开发者非常有用，并将 引领 JVM 走向一个充满发展潜力的新世界。 但有些新功能，如 coroutine 和 type alias（下文有几个例子）对于 Android 开发者来说就像科幻小说。 我们仍然停留在几乎没有什么改进的古老 Java 6 中，迫使我们以其他平台已经被被遗忘的方式进行开发。 所以一个理所当然的问题是：Kotlin 团队能够保持与 Java 6 的兼容性，同时保留所有这些新功能吗？答案是：当然！ 所有新特性仍然兼容 Java 6 为 Android 开发者所用。 今天我想向您展示其中的一部分，看看它们是如何使你更容易的开发 Android 应用程式。 type alias 使你的 listener 更易读当然 type alias 有很多不同的应用场景，不过我首先想到的是使用 lambda 作为 listener 的类型时会使代码更易读。 如果没接触过 type alias 的话，可以简单的理解为给复杂的类型名起个别名，使其更为可读。 例如你有个接收 listener 的 RecyclerViewAdapter。RecyclerView 没有 ListView 那样 标准的方式来处理条目点击事件，必须由开发者自己实现。 假如我们希望有一个可以访问 view 的 listener，那 adapter 可能如下所示： 123class MyAdapter(val items: List&lt;Item&gt;, val listener: (View) -&gt; Unit) : RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;() &#123; ...&#125; 而你的 ViewHolder 可能需要接收该 listener，才能将其分配给 view： 12345class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) &#123; fun bind(item: Item, listener: (View) -&gt; Unit) &#123; itemView.setOnClickListener(listener) &#125;&#125; 这不是一个复杂的例子，但是正如你所看到的我们需要重复定义这个 lambda ，会导致这段代码不太好阅读。 但是现在我们可以创建一个代表点击 listener 的 type alias：typealias ClickListener = (View) -&gt; Unit然后在需要的每一个地方使用它：class MyAdapter(val items: List&lt;Item&gt;, val listener: ClickListener)或者fun bind(item: Item, listener: ClickListener) { ... } data class 更强大了data class 可以为我们避免大量的样板代码，但是它不能继承其它类所以某些情况下不可用。 Kotlin 1.1 取消了这个限制，例如 data class 可以定义为 sealed class 的子类了： 12345sealed class UiOp &#123; object Show : UiOp() object Hide : UiOp() data class Translate(val axis: Axis, val amount: Int): UiOp()&#125; 同时 sealed class 可以在父类之外定义，就像这样的： 1234sealed class UiOpobject Show : UiOp()object Hide : UiOp()data class Translate(val axis: Axis, val amount: Int) : UiOp() 在 lambda 中使用 destructuring从 Kotlin 最早的版本开始 data class 就能够使用 destructuring declarations 了，因为它会自动生成 componentX() 方法，借助这些方法可以将 data class 对象拆分成若干变量，如下所示： 123data class Item(val text: String, val url: String) val (text, url) = item 可是在 Kotlin 1.1 之前你并不能在 lambda 上这么做。不过等待结束了！现在可以这么写： 1234fun bind(item: Item) = item.let &#123; (text, url) -&gt; textView.text = text imageView.loadUrl(url)&#125; 这个改进十分适用于操作 Pair 和 Map 等类型的对象 适用与局部变量的 delegated propertydelegated property 已被证明是非常有用的，可以为类中的 property 提供附加的能力。 例如最有用的一个是 lazy property，它会推迟赋值操作，直到变量第一次使用。 但其实 lazy 对于局部变量来说也是十分有用的，而之前 Kotlin 缺乏这个功能。 现在通过 delegated property，我们可以做到： 12345678910fun testLocalDelegation() &#123; val database by lazy &#123; createDatabase() &#125; val cache by lazy &#123; createMemoryCache() &#125; if (mustUseDatabase()) &#123; database.use &#123; ... &#125; &#125; else &#123; cache.use &#123; ... &#125; &#125;&#125; 虽然这个例子可以在没有使用 lazy 的情况下解决，但它有助于理解这个概念。 有一些占用比较多的对象不一定会被使用，可以通过使用 lazy 延迟实例化，直到我们初次使用它。 这时大括号内的代码会被执行，并且将结果缓存下来以备稍后再次使用。 再也不用在 lambda 中定义未使用的变量了在 lambda 中定义了变量但最终没使用情况很常见。 这是因为在 Kotlin 1.0 中没有办法丢弃 lambda 中未使用的参数。 例如使用 delegated property 更新 RecyclerView adapter，我使用了以下代码： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; prop, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; prop 变量从未被使用过，这时我们就可以使用下划线来替换它： 1234var items: List&lt;Content&gt; by Delegates.observable(emptyList()) &#123; _, old, new -&gt; autoNotify(old, new) &#123; o, n -&gt; o.id == n.id &#125;&#125; 还有种更糟的情况，如果 lambda 有多个参数，即使你一个也不用还是需要写上所有参数。现在我们可以忽略它们了： 1234var items: List&lt;Item&gt; by Delegates.observable(emptyList()) &#123; _, _, _ -&gt; notifyDataSetChanged()&#125; 不仅可以定义较少的变量，而且代码还变得更易读了，那些有用的变量一眼就能看到。 Coroutinecoroutine 是 Kotlin 1.1 中最令人兴奋的特性。尽管在此版本中带着“实验性”的标签，但 coroutine 功能齐全，你完全可以开始在项目中使用它们。 coroutine 能让你以同步的方式编写异步代码，允许你在某些时候暂停执行并等待结果，同时写下顺序相连代码。 您可能已经知道在 Kotlin 中 coroutine 并不是指一个库或者具体的实现，而是一种能力，通过它能够创建具有 coroutine 特性的库。 因此尽管某些代码看起来可能相似，但重要的是要知道创建这些辅助线程并返回主线程的“齿轮”是什么，这在 Android 中非常重要。 幸运的是 Kotlin 社区的动作很快，已经有几个库引入了 coroutine 方便我们在 Android 上使用。 首先来看看 Jetbrains 官方提供的： kotlinx-coroutines-android 提供了在 Android 上使用 coroutine 的实现。 Anko 在其最新的 beta 版中改写了部分框架引入 coroutine。 还有许多其他第三方库实现了自己的 coroutine 版本： AsyncAwait-Android by Niek Haarman Async / Await by Metalab 如果你在寻找 Retrofit 的 coroutine 版本，那么可以试试 kotlin-coroutines-retrofit by Andrey Mischenko 建议你们使用的时候看看它们是如何实现的，这就是开源的好处。 其它对 Android 开发者有用的东西这个版本还有更多的改进，但是我更想强调一些侧重于 Android 开发的内容。 首先，现在可以通过使用以下配置来启用 Jack 编译器的支持了：jackOptions {true}。虽然 Google 已经宣布放弃 Jack 工具链了，但是如果你对 Java 8 有需求那么会有一点用处，然后等到 Android Studio 2.4 的正式版发布就可以彻底弃用 Jack 了。（从 Android Studio 2.4 Preview 4 版本开始支持所有 Java 7 语言特性，部分 Java 8 语言特性） 另外介绍一个小技巧，就是用 @JvmOverloads 来实现自定义 View 的构造函数，在 Kotlin 中借助参数默认值一个构造函数就能满足自定义 View 的多种构造需求（嗯，很长的一个构造函数） 12345class CustomView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0) : View(context, attrs, defStyleAttr) &#123; ...&#125; 结论Kotlin 1.1 带来了大量的新功能，不禁让人产生为什么还要使用 Java 的想法。 Kotlin 为 Android 开发者带来的好处是毋庸置疑的，从现在开始使用 Kotlin 编写你的 Android 应用吧。 如果你想从头开始学习使用 Kotlin 开发 Android 应用，那么你应该会对 Kotlin for Android Developers 这本书感兴趣。","tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"https://kotlinandroid.net/tags/Coroutine/"},{"name":"Android","slug":"Android","permalink":"https://kotlinandroid.net/tags/Android/"},{"name":"typealias","slug":"typealias","permalink":"https://kotlinandroid.net/tags/typealias/"}]},{"title":"[译]Kotlin 1.1 Event in Your City","date":"2017-03-21T13:51:00.000Z","path":"2017/03/21/Kotlin 1.1 Event in Your City/","text":"我们将于2017年3月23日进行Kotlin 1.1活动 线上直播。您可以通过JetBrains TV观看Andrey Breslav的演讲，了解Kotlin 1.1的关键特性，包括协程(coroutines)，JavaScript后端等。您也可以使用#kotlinqa在twitter上提出问题，我们将在3月23日直播中的Q&amp;A环节进行解答。为适应不同的时区我们共准备了2个直播流，详情可在博客日志中参阅详细计划与指导 。从下图中了解您所在的城市是否有Kotlin 1.1活动，如果您所在的城市尚未出现在下图中，请单独加入直播。 请注意，美国的直播时间已经更改为PDT(太平洋夏季时间)时间。第一个直播流将于上午9点开始，第二个上午11点开始。","tags":[]},{"title":"[译]Kotlin 1.0.7 is out","date":"2017-03-15T14:21:00.000Z","path":"2017/03/15/Kotlin 1.0.7 is out/","text":"我们很高兴地宣布Kotlin 1.0.x系列的最后一个更新，Kotlin 1.0.7已经发布了。需要重点关注的是该补丁针对Gradle和annotation processing进行修复，此前无法升级到1.1版本的用户现在可以正常使用了。完整的修复列表可以在更新日志查看。要在Maven或Gradle版本中更新版本，只需在构建脚本中更改Kotlin版本号。命令行编译器会在Github发行页面中下载。在IntelliJ IDEA和Android Studio中，如果您使用Kotlin 1.0.7构建项目，我们建议使用1.1版本的插件，并将语言版本切换为1.0。如果您确实想要安装1.0.7版本的插件，可以在Kotlin插件页面下载相应版本，并通过IDE的“从磁盘安装插件…”按钮进行安装。一如既往，如果您在新版本中遇到任何问题，欢迎您在讨论组或者Slack（在这里获得邀请）里寻求帮助，或在这里提交issue。让我们来享受Kotlin吧！","tags":[]},{"title":"[译]Kotlin 1.1.1 is out","date":"2017-03-14T12:29:00.000Z","path":"2017/03/14/Kotlin 1.1.1 is out/","text":"今天我们发布了针对 Kotlin 1.1 的第一个bug修复更新。此更新的重点是解决导致错误代码生成的回归；我们希望尽可能快地修复此问题。详细内容请查看更新日志 。重点更新如下： 默认情况下，已启用Gradle增量编译。如果需要，您仍然可以按照文档描述禁用此功能。 Kotlin插件现已可以通过Gradle插件依赖添加使用。详情可参阅相关文档。 禁用使用带有接收器的函数类型作为JavaScript外部声明的参数类型。在此之前，传递给这些参数的lambdas没有被正确的参数调用，并且在这个问题上没有简单的解决方法，所以现在我们决定禁用这个功能。 更新后的Kotlin Eclipse 和 NetBeans 插件将支持Kotlin 1.1.1，所以您可以尽情享受Kotlin新版本的优点而无需关注IDE。 如何更新要更新IDEA插件，在菜单栏中依次选择 Tools | Kotlin | Configure Kotlin Plugin Update，然后点击“Check for updates now”按钮。另外，不要忘记在Maven和Gradle构建脚本中更新编译器和标准库版本 命令行编译器可以从 Github发布页面 页面下载。像往常一样，如果您在新版本中遇到任何问题，您可以在 论坛 中寻求帮助，在Slack(获取邀请)、或者在问题追踪器提出问题 。让我们开始吧！","tags":[]},{"title":"[译]Kotlin 1.1 Event","date":"2017-03-06T09:43:00.000Z","path":"2017/03/06/Kotlin 1.1 Event/","text":"Kotlin 1.1除了为您的项目带来新特性之外，还是您与当地社区进行线下交流学习、了解Kotlin的未来与发展的绝好机会。您可以组织社区的小伙伴们，一起参与Jetbrains团队在3月23日举办的Kotlin直播活动。为了适应不同时区，我们准备了两个直播流，分别是欧洲中部时间[CET]下午5点/7点(太平洋夏季时间[PDT]上午9点/11点)。 告诉我们，我们将在博客上公布。 Kotlin 1.1活动时间： CET时间下午5点/7点(PDT时间上午9点/11点) - Andrey Breslav演讲(Youtube上直播30分钟)，链接将稍候放出。 CET时间下午5点30分/7点30分(PDT时间上午9点30分/11点30分) - 休息30分钟，期间可以自由讨论关于在Kotlin未来版本中您最希望加入的功能或特性，并在Twitter上分享和评论。 CET时间下午6点/8点(PDT时间上午10点/12点) - 与Kotlin团队的互动问答环节(45分钟，直播); 欢迎各位参与讨论与发言。 互动问答环节 从3月21日开始，至3月23日互动环节结束期间，您可以在Twitter上使用#kotlinQA标签向我们提出任何您想要问的问题； Kotlin团队将对问题进行分类; 团队将在Q＆A环节现场回答问题; 如果在会议期间有问题没有答复，我们仍将通过Twitter进行回复 优先回答提问频率最高的问题 Future Features kit本次调查的目的是收集社区用户对语言特征的偏好和需求。您可以提出在Kotlin后续版本中最希望看到的特征或功能；不过这些内容并不保证能在1.2版本中发布，但我们会在确定工作优先级时考虑您的意见。 Kotlin Future Feature Kit包含20张写有功能名称和描述的卡片以及用于投票的贴纸; 将功能卡片粘贴到白板（或墙壁）上; 每位参加者可获得3张（3张）贴纸，可以在功能中自由分配：最多为三种不同的功能进行投票，或者对某一功能投出两票甚至三票; 参加者可以通过阅读卡片的说明了解功能，然后按上所述规则进行投票; 将结果进行拍照; 使用#kotlinevent标签在Twitter上发布 在这里提交你的答案吧","tags":[]},{"title":"Kotlin 1.1","date":"2017-03-04T00:46:34.000Z","path":"2017/03/04/Kotlin 1.1/","text":"上周一的文章里面提到 Kotlin 1.1 rc了，还没正式发布，我在周三的时候把文章转到掘金以后，好多小伙伴告诉我，1.1 已经发布了~ tips: 本文有较多外链，公众号阅读时无法跳转，如有需要，请大家点击”阅读原文”。 1、更新要点1.1 Coroutine1.1 最大的更新一定必须毫无疑问的要数 Coroutine 了，尽管在正式发版之前，Kotlin Team 突然虚了，决定把这个特性定为 Experimental，不过这似乎并没有改变什么。不就是改个包名么！！ 早在春节放假那几天，我就在公众号连续两周发文介绍 Coroutine，本来还计划有第三篇的，不过开工以后个项目有点儿累，每天翻 Android 系统 C++ 层的代码翻到吐，也没精力去写第三篇文章，真是抱歉，如果大家有兴趣，可以参考前两篇： 深入理解 Kotlin Coroutine (一) 深入理解 Kotlin Coroutine (二） 其中，第一篇文章写于 experimental 之前，不过大家只要在包名当中加上 experimental 就没问题了。 Kotlin 的 Coroutine 实现主要分为两个层面，第一个层面就是标准库以及语言特性的支持，这里面主要包括最基本的 suspend 关键字以及诸如 startCoroutine 这样的方法扩展，上述第一篇文章对此做了详细的介绍。第二层面则主要是基于前面的基础封装的库，目前主要是 kotlinx.coroutine ，其中封装了 runBlock、launch 这样方便的操作 Coroutine 的 api，这在第二篇文章做了详细地介绍。所以大家在了解 Coroutine 的时候，可以从这两个角度来入手，以免没有头绪。 我们再来简单说说 Coroutine 的运行机制。Coroutine 是用来解决并发问题的，它甚至有个中文名叫“协程”，它看上去跟线程似乎是并发问题的两种独立的解决方案，其实不然。要并发的执行任务，从根本上说，就是要解决 Cpu 的调度问题，Cpu 究竟是如何调度，取决于操作系统，我们在应用程序编写的过程中用到的 Thread 也好，Coroutine 也好，本质上也是对操作系统并发 api 的封装。知道了这一点，我们再来想想 Thread 是如何做到两个线程并发执行的呢？Java 虚拟机的实现主要采用了对内核线程映射的方式，换句话说，我们通常用到的 Thread 的真正直接调度者可以理解为是操作系统本身。那我们在 Kotlin 当中支持 Coroutine 是不是也要把每一个 Coroutine 映射到内核呢？显然不能，不然那跟 Thread 还有啥区别呢？再者，Coroutine 的核心在 Co 上，即各个 Coroutine 是协作运行的，有一种“你唱罢来我登场”的感觉，就是说，Coroutine 的调度权是要掌握在程序自己手中的。于是，如果你去了解 kotlinx.coroutine 的实现，你就会发现 CommonPool 这么个东西，它不是别的，它的背后正是线程池。 线程是轻量级进程，而协程则是轻量级线程。 Coroutine 的出现让 Kotlin 如虎添翼，如果你之前在写 Go，Lua，python，或者 C#，这回 Java 虚拟机家族可不会让你失望了。自从有了协程，你也可以写出这样的代码： 12345678910111213141516val fibonacci = buildSequence &#123; yield(1) // first Fibonacci number var cur = 1 var next = 1 while (true) &#123; yield(next) // next Fibonacci number val tmp = cur + next cur = next next = tmp &#125; &#125; ... for (i in fibonacci)&#123; println(i) if(i &gt; 100) break //大于100就停止循环 &#125; 序列生成器，记得我刚学 python 那会儿看到这样的语法，简直惊呆了。 123val imageA = loadImage(urlA) val imageB = loadImage(urlB) onImageGet(imageA, imageB) 这样的代码也是没有压力的，看上去就如同步代码一般，殊不知人家做的可是异步的事情呐。 协程的出现，让我们可以用看似同步的代码做着异步的事情。 这篇文章我们主要说说 1.1 的发版，Coroutine 的更多内容，建议大家直接点击前面的链接去读我的另外两篇文章~ 1.2 JavaScript 支持真是媳妇儿终于熬成婆，Js 终于被正式支持了。看官方的意思，他们已经用这一特性做了不少尝试，从 Kotlin 从头到尾写一个站点，似乎毫无压力，尽管类似反射这一的特性还没有支持，不过面包会有的嘛。 从我个人的角度来说，也可能我对前端了解太少吧，我觉得应用在前端比起移动端、服务端来说，Kotlin 的前景相对不明朗。我用 JavaScript 用得好好的，为啥要切换 Kotlin 呢？动态特性玩起来挺爽的，虽然回调写多了容易蛋疼，但这也不是不可以规避的。关于 Kotlin 开发前端这个问题，我需要多了解一下前端开发者的看法，相比他们是否愿意接触 Kotlin，我更关心有几个做前端的人知道这门语言。不瞒各位说，前几天跟一个支付宝客户端的大哥聊了一会儿，他问我这个 k o t 什么的，是干啥的。。。我当时在想，看来阿里人对 Kotlin 还不是很熟悉啊。 Whatever，Kotlin 现在都可以支持 node.js 了，还有什么不可能的呢？作为吃瓜群众，且让我观望一阵子。 1.3 中文支持你放心，这一段内容你绝对在其他人那里看不到，因为没人会这么蛋疼。我前几天为了做一个案例用中文写了段代码，想着 Java 支持中文标识符，Kotlin 应该也问题不大。没曾想，写的时候一点儿问题的没，可编译的时候却直接狗带了。 123456789101112package 中国.北京.回龙观 class G6出口&#123; fun 下高速()&#123; println(\"前方堵死, 请开启飞行模式 :)\") &#125; &#125; fun main(args: Array&lt;String&gt;) &#123; val 回龙观出口 = G6出口() 回龙观出口.下高速() &#125; 注意，包名、代码文件名都是中文的，如果用 1.0.6 版编译，结果就是万里江山一片红哇。 1234567Error:Kotlin: [Internal Error] java.io.FileNotFoundException: /Users/benny/temp/testKotlin/out/production/testKotlin/??/??/???/G6??.class (No such file or directory) at java.io.FileInputStream.open0(Native Method) at java.io.FileInputStream.open(FileInputStream.java:195) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138) at kotlin.io.FilesKt__FileReadWriteKt.readBytes(FileReadWrite.kt:52) at org.jetbrains.kotlin.incremental.LocalFileKotlinClass ... 注意到，汉字都变成了 ??，瞧瞧编译器那小眼神，真是看得我都醉了。 如果我们用 1.1 的编译器来编译这段代码，结果就可以正常输出： 1前方堵死, 请开启飞行模式。 1.4 其他特性1.1 还新增了不少特性，我在之前的一篇文章就做过介绍：喜大普奔！Kotlin 1.1 Beta 降临~ tpyealias 绑定调用者的函数引用 data class 可以继承其他类 sealed class 子类定义的位置放宽 _ 作为占位，替代不需要的变量 provideDelegate 2、Kotlin 元年2016 年是 Kotlin “元年（First year of Kotlin）”，官网给出了这样一幅图来展示它一年来的成绩： Github 上面的代码量都破千万了，使用 Kotlin 的公司也逐渐增多，除了 JetBrains 自己以外，我觉得在 Java 界比较有分量的就是 Square 了，如果 Google 能够稍微提一句 Kotlin ，显然这个故事就会有另外一个令人兴奋的版本——好啦，不要 yy 啦。 据说，比较著名的主要有Amazon Web Services, Pinterest, Coursera, Netflix, Uber, Square, Trello, Basecamp 这些公司将 Kotlin 投入了生产实践当中。国内资料较少，估计接触的人也不是很多，像百度、腾讯、阿里巴巴、滴滴、新美大、小米、京东这样的公司可能还没有太多的动力去将 Kotlin 应用到开发中，就算开始尝试，也多是在 Android 开发上面试水；而敢于尝试 Kotlin 的，更多是没有什么历史包袱且富于创新和挑战精神的创业团队，对于他们而言 Kotlin 为开发带来的效率是非常诱人的。 说到这里，有两个令人兴奋的消息需要同步给大家： Gradle 开始尝试用 Kotlin 作为其脚本语言，目前已经发到了 0.4.0。这个真的可以有，groovy 虽然是一门很灵活的语言，不过写配置的时候如果没有 IDE 的提示，实在是太痛苦了。大家有兴趣也可以关注一下这个项目：gradle-script-kotlin Spring 5.0 加入 Kotlin 支持，Spring 的地位可想而知，Spring 为 Kotlin 站台，这分量还是很重的。 不知道 2017 年会发生什么，且让我们准备好爆米花饮料，拭目以待吧。 关于 Kotlin 的资料，英文版的图书已经出版了几本，主要有： Kotlin in Action：这部书已经有了纸质版，是官方自己人写的，算是一本比较权威的参考书了。 Kotlin for Android Developers：这本书也算是老资历了，稍微看几眼你就会为 Kotlin 有趣的特性所吸引。另外，它还有一个中文的翻译版本 Modern Web Development with Kotlin：这本书我没有读过，如果你需要用 Kotlin 开发 web 应用，它应该会给予你一些帮助。 Programming Kotlin：这本书涉及内容非常全面，内容也算是言简意赅，快速入门 Kotlin 可以选择它。 除了图书以外， Kotlin 的首席布道师 Hadi Hariri 已经在 O’Reilly 上面发布了两套视频教程： Introduction to Kotlin Programming Advanced Kotlin Programming 里面有免费的几段，且不说内容怎么样，反正考验大家英语听力的时候到了，嗯，老爷子讲得还是很清楚的。 国内的资料，很少。除了有个别小伙伴写的一些博客之外，较为系统的学习资料几乎没有。也难怪大家都不知道它呢。也正是为了弥补这一空白，我在 16 年 10 月的时候开始每周 10 分钟的节奏连续录了 15 期视频，如果你有 Java 基础，那么看这些视频基本上可以让你知道 Kotlin 是怎么一回事了。 Kotlin 中文视频教程 另外，如果你想要对 Kotlin 持续了解，建议你关注微信公众号 Kotlin，每周一推送的 Kotlin 的相关文章，基本上会覆盖了 Kotlin 的各种最新动态。也欢迎大家跟我交流开发中遇到的问题~ 3、Kotlin 时代1.1 的重要的更新其实就 Coroutine 以及 JavaScript 支持，毕竟 Kotlin 对 Java 的兼容支持已经做得非常不错了（别老提 apt 的事儿，1.0.4 之后的 kapt 不就基本上很好用了么）。别人问我，Kotlin 到底是写啥的，这个问题我通常说很官方的说，Kotlin 是一门运行在 Java虚拟机、Android、浏览器上的静态语言，可是，Kotlin Team 的节奏已经让这句话显得要过时了。他们用短短几年时间搞出这么个全栈的语言，各方面特性都还很棒，然而他们并不能感到满足，他们已经开始走 C++ 的路线，也许 Kotlin Native 要不了多久就会出现了。 第一次听到这消息的时候，我瞬间就凌乱了，那感觉就好像王者荣耀里面队友选了大乔一样，秒回泉水加满血，秒回战场收人头啊。 前不久，我很荣幸地跟一位创业公司 CEO 坐下来聊理想，他问我的第一句话就是：你觉得 Kotlin 是未来么？我当时就蒙了，不得不说，他对 Kotlin 的期待跟 Kotlin Team 如出一辙呀。我当时实在不知道该怎么回答他，回来仔细想了想，答案其实也是有的。 十几年前，东家缺钱，急需投资，投资人坐下来“拷问”小马哥：“这个东西（指当时的 OICQ）怎么赚钱？” 小马哥说自己只知道这个东西大家喜欢，但不知道向谁收钱。对于 Kotlin 来说，我只知道它好用，尽管大家都还看不太懂，不过它的时代正在悄悄的到来。","tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"https://kotlinandroid.net/tags/Coroutine/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://kotlinandroid.net/tags/JavaScript/"},{"name":"中文支持","slug":"中文支持","permalink":"https://kotlinandroid.net/tags/中文支持/"},{"name":"Kotlin元年","slug":"Kotlin元年","permalink":"https://kotlinandroid.net/tags/Kotlin元年/"}]},{"title":"[译]Kotlin 1.1 发布啦！JavaScript，Coroutine 还有更多你想要的","date":"2017-03-01T09:12:00.000Z","path":"2017/03/01/Kotlin 1.1 Released with JavaScript Support, Coroutines and more/","text":"Kotlin 1.1 今天正式发布了，这让 Kotlin 有能力适用于更多的应用场景，希望大家能够喜欢。 我们希望 Kotlin 能够在应用的任何组件中成为独立的、富有表现力且性能强大的强类型语言，Kotlin1.1 为了实现这一目标迈出了巨大的两步。 首先，JavaScript 支持的“试验性”标签已被移除，并且支持所有 Kotlin 语言特性、标准库的大部分内容以及 JavaScript 互操作性。这意味着开发者可以完全使用 Kotlin 来编写整个 WEB 应用，同时继续使用 JavaScript 的开发框架（比如 React）。 其次，我们引入了协程(coroutines)的概念。作为线程的轻量级替代方案，协程在应用程序后端可以具有更大可扩展性，从而支持单个 JVM 实例上的大量工作负载。除此之外，协程对于实现异步行为具有强大的表现力，这对于在任何平台上构建响应式用户交互界面而言极其重要。 下面我们将进一步介绍这两大功能。其他部分如type aliases，callable references，destructuring in lambdas等详情可在最新消息查看，试试完整的可运行示例代码！ 协程(Coroutines)在 Kotlin 中协程使非阻塞式异步代码与同步代码一样易于理解。 异步编程正当风靡，唯一让我们思虑的是，非阻塞式代码大量增加了系统的复杂性。 而 Kotlin 现在提供了简化这种复杂性的方法，通过单原子让协程在语言中成为一等公民：挂起函数。这种类型的函数（或 lambda）表示在计算运行中可以被挂起（不阻塞任何线程），而后也能继续恢复运行。 从技术上说，协程是多任务协作的轻量级解决方案（类似于fibers)）。换言之，他们只是更好的线程：可以任意的启动和保留，且挂起的消耗极其之低（挂起之于协程，如阻塞之于线程），非常易于组合与订制。 我们对于协程的设计以实现最大的灵活性为目标：在语言中固化的部分少，而且可以作为库来实现很多功能。kotlinx.coroutines项目在 Rx，CompletableFuture，NIO，JavaFx 和 Swing 上均有设计功能库，甚至可以为 Android 和 JavaScript 编写类似的库。即使在其​​他语言中许多内置构建现在也可以用 Kotlin 库来编写。包括 Python 的 generators/yield，来自 Go 的 channels/select 以及 C＃的 async/await: 12345678910111213141516// runs the code in the background thread poolfun asyncOverlay() = async(CommonPool) &#123; // start two async operations val original = asyncLoadImage(\"original\") val overlay = asyncLoadImage(\"overlay\") // and then apply overlay to both results applyOverlay(original.await(), overlay.await())&#125; // launches new coroutine in UI contextlaunch(UI) &#123; // wait for async overlay to complete val image = asyncOverlay().await() // and then show it in UI showImage(image)&#125; 查看完整内容。 重要提示：凭借上述的这些优势，Kotlin 协程近乎全新的设计，在我们能确定这是 100％正确和完整之前，仍然需要大量的实践和测试。因此我们才选择在“实验性”标志下发布。我们不希望语言规则发生变化，但 API 可能需要在 Kotlin 1.2 中进行调整。 JavaScript 支持如上所述，Kotlin 1.1 中的所有语言特性（包括协程）都适用于 JVM / Android 和 JavaScript（JavaScript 的反射目前不可用，但我们正在这方面努力）。这意味着 Web 应用程序可以完全使用 Kotlin 编写，而且我们已经在 JetBrains 内部有一些尝试，相信很快就会发布教程和其他资料。 Kotlin for JavaScript 具有与“源生”JavaScript 代码进行互相操作的动态类型，通过类型 API 可以使用ts2kt converter以及DefinitelyTyped等知名库。 我们支持 Node.js 和浏览器。 Kotlin 标准库可通过npm使用。文档链接 。 工具Kotlin 1.1 并不是 Kotlin 工具发布的主版本：我们更喜欢具有这些功能的工具就绪后，不会对语言本身产生影响，所以我们在 Kotlin 1.0.x 版本中的有许多这样的改进： 主流 IDE 的 Kotlin 插件：IntelliJ IDEA，Android Studio，Eclipse 和 NetBeans IntelliJ IDEA 和 Gradle 中的增量编译 Spring，JPA 和 Mockito 的编译器插件（all-open 与 no-arg） 注解处理器 kapt 对 Android 项目的支持 Lint 检查 大量的 IDE 代码预测，检查，快速修复，重构和自动完成提升 我们将继续在 1.1.x 版本中进行更新，努力为开发者们提供更好的工具。 Kotlin 元年：迁移与社区总而言之，Kotlin 正在逐渐壮大。去年，我们看到有超过 160,000 人使用，Github 上的 Kotlin 开源项目从 2.4M 增加到 10M（约 4 倍）。我们的 Slack 社区已经从 1,400 人增长到超过 5,700 人（超过 4 倍）。世界各地均有社区组织了众多的线下交流以及用户群组，我们也看到越来越多的 Kotlin 书籍和在线课程发布。 Kotlin 在服务器端和 Android 端（开发人员数量均等）表现异常强大。 Spring 框架 5.0和vert.x 3.4均引入了对 Kotlin 的支持。 Gradle和TeamCity正在使用 Kotlin 构建脚本。更多使用 Kotlin 的项目可以在kotlin.link查看。 许多知名公司也正在使用 Kotlin：Pinterest，Coursera，Netflix，Uber，Square，Trello，Basecamp；除此之外， 由知名银行（如高盛，富国银行，摩根大通，德意志银行，瑞银，汇丰银行，法国巴黎银行，SociétéGénérale）联盟开发的分销账户分类账户Corda，其代码库中有超过 90％的部分使用 Kotlin。我们感谢世界各地的所有用户，贡献者和倡导者。您的支持对我们非常重要！ 组织您自己的 Kotlin 1.1 活动Kotlin 1.1 的发布是与当地社区好友线下聚会的好话题。我们已经准备了一些资料来帮助开发者们举办此类活动。3 月 23 日，我们将以 Kotlin 团队成员的形式进行现场直播，发起人均可获得一个背包，里面有一份关于未来特性的调查问卷和一些小礼物，点击注册即可参与。 后续为了使 Kotlin 成为真正的全栈语言，我们将为多个平台编译相同的代码提供工具和语言支持。这将有助于在客户端和服务器之间进行模块共享。我们将继续致力于改进 JavaScript 工具和库的支持。除此之外，JavaScript 平台的增量编译正在进行中。请继续关注 1.1.x 更新。 Java 9 即将推出，我们将在发布之前为其新功能提供支持。 我们期望在未来几个月内能够收到许多关于协程反馈意见，改进这一领域（在性能和功能方面）对于我们优先级最高。除此之外，下一版本的主要工作将集中在维护，性能改进，基础架构和错误修复方面。P.S 跨平台运行是 Kotlin 的战略方向，伴随着 1.1 的发布，我们可以在服务器，台式机，Android 设备和浏览器上运行，但是未来我们将把 Kotlin 编译为本地代码，并使之能够在更多平台（例如 iOS 和嵌入式设备等）上运行。 目前在 JetBrains 内部，有一个非常棒的团队正在开展这个项目，我们期待很快就会出现有趣的东西，不过尚未计划为此专门发布任何版本。 安装说明与以往一样，开发者可以使用Kotlin 线上编辑器 try.kotlinlang.org。 Maven/Gradle：使用1.1.0作为编译器和标准库的版本号(查看文档)。 IntelliJ IDEA：2017.1 已包含 Kotlin 1.1；旧版本则需要安装 Kotlin 插件或更新到 1.1 版本。 Android Studio：通过Plugin Manager安装或更新插件。 Eclipse：使用Marketplace 安装插件。 命令行编译器可以从Github 发布页面下载。 兼容性：Kotlin 1.1 语言和标准库向后兼容(modulo bugs) ：如果使用 1.0 版本编译运行，1.1 版本仍然可以运行。为了帮助大型团队有规律的更新，我们在编译器中新增禁用新功能的开关。查看踩坑文档。 请尽情享受 Kotlin！ P.S: 在Reddit和Hacker News上加入讨论吧！","tags":[]},{"title":"Kotlin 1.1：我们在路上","date":"2017-02-20T02:32:32.000Z","path":"2017/02/20/Kotlin 1.1：我们在路上/","text":"►1.1 RC 来了，Release 还会远吗？ 去年 2 月 19 日 1.0 发版，我记得此前看到论坛上面开始讨论 1.0 API 趋于稳定的话题，想想都还挺兴奋呢，一不留神，Kotlin 1.0 在稳定奔跑一年之后，也终于迎来下一个版本：就在前天（17日），我留意到 Kotlin 官博发出了 1.1 RC(Release Candidate) 的消息，截止到目前，1.1 的所有开发工作都已经进入尾声，剩下的就只有我们期待的眼神了。 ►成长，一路有你 2016 这一年发生了挺多的事情，最重要的就是 Kotlin 终于有一个正式的版本，开始了按部就班的日子：每两个月一个正式版本以及一个 1.1 的里程碑版本。接着，我们也很快的发现我们期待的功能都悄悄的走进了 Kotlin 的更新日志，Kotlin 正一天一天的成长起来。 不知道各位看官年龄几何，对我来说，C 和 C++ 太老，Java 虽然小了一些，可它诞生的时候我还在小学里面玩 Dos；而当我真正开始认识它们的时候却发现它们实在是太庞大了，有时候甚至觉得可怕，有时候更是没办法理解它们。它们是编程语言的长者，而我，只是一个年轻的程序员。 Kotlin 则不一样了。它出现的不算早，大概 2010 年的样子吧，那个时候我刚刚闲来无事考了个软考中级的 “软件设计师”，一个在学校里面随处可见的“小黄书”背后的没有多大用处的考试，那个时候大概是我基础最好的时候吧。后来 Kotlin 逐渐成长起来，而我也逐渐脱离了象牙塔里的天真，冲向了努力干活历练自己的道路中间。 ►还记得，你与 Kotiln 的第一次相遇吗？ 最早认识 Kotlin 还是在 15 年初，那时候我正热衷于编写 IntelliJ 的插件，尽管后面成果空空，不过一些个莫名其妙的后缀为 kt 的文件却着实让我头疼不已。尽管照着说明安装好 Kotlin 的插件，可因为版本不一致，始终无法编译过去，真是无可奈何啊。当时我还想，又有新语言啊，这可当真是学海无涯咯。 不过，随着接触的机会逐渐增多，我发现 Kotlin 解决了很多我对 Java 不满的问题，而它呢，却又全力支持着 Java 中的一切，始终让我们感觉不到我用了另外一种语言，语法的那点儿差异说真的比起不同语言背后的编程思维的差异来说，简直不值得一提。我在同时尝试了 groovy 和 scala 之后，觉得 Kotlin 才是我想要的，于是在 Kotlin 1.0 发布之际，我向 Bugly 公众号投稿文章：Android 必备技能：最有可能接替Java的语言——Kotlin ，把我眼中的 Kotlin 向大家展现了出来。 ​►Kotlin 给你带来了什么？去年上半年有段时间经常奔波在北京和深圳之间，工作节奏“日新月异”，项目似乎进入了一种莫名其妙的状态，而我自己则犹如置身死水，所幸我也是上过王者的人了，也不枉费我那一段时间在上面投入的一个个不眠之夜吧。 那段时间，我对项目的代码有我“自以为是的足够”的祸害的自由，于是我开始肆无忌惮的用 Kotlin 写一些模块，完全没有顾及合作开发的我们组唯一的妹子的感受。以及，这代码后来落入导师手中，我也算是坑他们不浅呐。不过，如果没有这段经历，或许我后来也不会有那么大的底气去在 10 月份斗胆录制视频，也自然不会去开公众号每周发几篇水文了。说来，得好好谢谢他们。 话说，自从摊上这么个事儿，我只好每天早晨 6 点起来或写写东西，或看看书，学点儿东西，每天节奏也极其规律，中午再也没没有精力跟小伙伴们组团王者了，因为我得睡一个小时。 年前我又在 Bugly 公众号发了一篇文章：你为什么需要 Kotlin，结果大家都说我是被代码耽误了的段子手，呃。。我想说你们说的很对！ 承蒙各位朋友厚爱，经常提及后续视频录制的问题，我正在尝试重新录制一套较为细致和基础的视频，目前讲义已经编写完毕，至于发布时间，那得看我啥时候录得完啦。 末了，建议大家有事儿没事儿也都写写，我最开始在公司内部写文章刷积分玩，后来发现自己写的东西经常需要复习；不仅如此，很多时候遇到一个问题，可能最终用某种方式解决了，你以为这个问题你是搞清楚了的，不过，一旦你企图将其形成文字，你就会发现问题的背后将会是更多的细枝末节。俗话说得好，好记性不如啪啪啪的机械键盘啊！","tags":[{"name":"成长","slug":"成长","permalink":"https://kotlinandroid.net/tags/成长/"}]},{"title":"[译]Kotlin 1.1 候选版本来啦","date":"2017-02-17T05:37:00.000Z","path":"2017/02/17/Kotlin 1.1 Release Candidate is Here/","text":"截至今天，Kotlin 1.1 终于到了候选版本（RC）阶段。这意味着大部分开发工作都已经完成，我们对此结果感到满意，很快就会发布 Kotlin 1.1 正式版。我们已经在内部对此版本进行了大量测试，但现实世界总是比任何测试环境更加多样化，因此我们需要您的帮助。请尝试这个版本，让我们知道您的体验！ 候选版本中唯一的新功能是 takeUnless 函数，它对应 1.1 之前添加的 takeIf，但判断条件相反。至于错误修复则有很多，完整清单请查看更新日志。除此之外，我们还修复了几个 IDE 中的性能问题，包括长期存在和最近回归才出现的。 迁移说明就像我们之前提到的，预发布版本生成的所有二进制文件不能在当前的编译器下使用：您现在需要重新编译由 1.1-M0x 和 Beta 编译的所有内容。当然，从 1.0.x 开始的所有代码都不需要重新编译。 在这之前，您可以从 Java 6 开始，以任何版本的 Java 运行 Kotlin 编译器，但这从第一个 1.1.x 更新开始有变化，编译器将仅在 Java 8 或 9 下运行。为您准备迁移，编译器现在会在 Java 6 或 7 下运行时发出警告。请注意，这仅影响构建环境；编译代码默认情况下仍然与 Java 6 兼容，我们没有计划删除对它的支持。 现在不推荐使用 .javaClass 扩展属性。作为替代，请使用 ::class.java。IDE 提供了一个 quickfix 来更新写法，单独的修改或者更新整个项目。 为了减小 JavaScript 标准库的大小，我们已经将 kotlin.dom 和 kotlin.dom.build 包中的大量辅助函数注解为不推荐使用了，然后在将来的更新中删除它们。 如何尝鲜在 Maven/Gradle 中： 将 http://dl.bintray.com/kotlin/kotlin-eap-1.1 添加为构建脚本和项目的仓库；使用 1.1.0-rc-91 作为编译器和标准库的版本号。 在 IntelliJ IDEA 中： 点击菜单 Tools → Kotlin → Configure Kotlin Plugin Updates，然后在 Update channel 的下拉列表中选择 “Early Access Preview 1.1”，接着点击 Check for updates。 在 Eclipse 中： 从以下更新站点安装插件https://dl.bintray.com/jetbrains/kotlin/eclipse-plugin/0.8.0 The command-line compiler 可以从 Github 发布页面下载。最后，让我们开启 Kotlin 之旅吧！try.kotlinlang.org。","tags":[]},{"title":"Kotlin 1.1 Beta 2 发布~","date":"2017-02-06T00:14:15.000Z","path":"2017/02/06/Kotlin 1.1 Beta 2 发布~/","text":"1 协程改包名风波说真的，看到这个标题的时候我还挺兴奋，离 release 又近了一步。不过，看了这篇文章的时候，我就觉得也是醉醉的。发生了啥呢？ 原来，协程相关的依赖统统被标记为 experimental 了，以前叫： 1package kotlin.coroutines 现在呢？ 1package kotlin.coroutines.experimental 这意味着啥？意味着我们在这次更新之后，还得把原来的协程代码的包重新导入一遍，另外，如果你想使用协程，那么你还需要在配置当中呢启用它，例如 gradle 配置需要加入： 12345kotlin &#123; experimental &#123; coroutines 'enable' &#125; &#125; 你在升级所有的依赖的时候，确保它是兼容 1.1.0-beta-38 的，这一点很重要，不然等着报错吧！ 话说，为啥要这么搞呢？按照官方的说法就是，协程这个特性目前已经实现的非常不错了，内置 API 非常少，灵活扩展性也强，不过他们觉得这个东西还有很大的潜力，也不能就这样作为最终版本给大家放出来，而作为实验特性交给大家使用呢，更多地还是希望大家能提提意见啥的。嗯，说实在的，协程这个特性真不是个小特性。 2 兼容 1.0话说，1.1 的编译器终于声称兼容 1.0 的源码了，这表明我们再也不用搞两个 IntelliJ 分别装 1.0 稳定版的插件和 1.1 Beta 版的插件了。 是的，就算你不用 1.1 的特性，你装 1.1 的插件，用 1.1 的编译器，写 1.0 的代码毫无压力！！ 什么？你问我试了没？当然，我一直用最新的插件，折腾地挺苦的 T T，劝诸君还是装稳定版吧，吃螃蟹要做好心理准备~！ 3 小结浏览了一下 1.1Beta 2 的主要特性，其实就是改改包名，修几个小 Bug，大的改动基本没有了。如果大家想要尽早上手 1.1 的特性，那么就从现在开始吧~","tags":[{"name":"Coroutine","slug":"Coroutine","permalink":"https://kotlinandroid.net/tags/Coroutine/"},{"name":"兼容","slug":"兼容","permalink":"https://kotlinandroid.net/tags/兼容/"}]},{"title":"Kotlin 1.0.6","date":"2017-01-02T08:22:57.000Z","path":"2017/01/02/Kotlin 1.0.6/","text":"我把所有文章和视频都放到了 Github 上 ，如果你喜欢，请给个 Star，谢谢~ 在上周二，Kotlin 1.0.6 发布啦！这次更新主要是工具更新和bug修复。本文的内容主要来自官方博客。 IDE 插件的更新 try-finally 转换为 use() 通常我们在进行 IO 操作的时候，我们并不希望异常影响我们程序的执行，所以我们需要对异常进行捕获，但捕获的话我们也没有必要处理，所以写下来的就是下面的形式： 12345try&#123; ... do something with \"reader\" ...&#125;finally&#123; reader.close()&#125; 但这样写起来是不是非常的不流畅？如果用 use() 的话，简直一气呵成： 123reader.use&#123; reader -&gt; ... do something with \"reader\" ...&#125; 所以，这次更新 Kotlin 的插件为我们带来了这样的自动转换功能： 补全具名参数 通常我们在编写代码的时候，函数入参都会按照顺序一个一个传入，不过随着代码量的增加，特别是对于参数较多的函数，一长串的代码看上去会让我们感到非常的头疼。所以，这次更新 Kotlin 还为我们带来了自动补全具名参数的功能。 删除空构造方法的声明 合并声明和赋值 inline 函数的问题修复和调试工具的优化 提示、KDoc 和 Quick Doc 相关的较多问题的修复 Android 相关更新 支持 Android Studio 2.3 beta 1 和 Android Gradle Plugin 2.3.0-alpha3及更新的版本 增加 “Create XML resource” 的提示 Android Extensions support 这个功能可以让我们很方便的引用 XML 布局的 View，不过这需要我们主动启用 ‘kotlin-android-extensions’ 才行。在过去，即使不启用这个插件，IDE 也会允许我们直接引用 XML 布局的 View，但这并不能正常编译，所以这次更新修复了这个问题：只有启用了这个插件，IDE 才会允许我们引用对应的 View。 Android Lint 相关的问题修复。 增加 Suppress Lint 提示。 Kapt 优化尽管还不能完全支持增量编译，相比 1.0.4，这次更新较大的提升了 Kapt 的性能。如果需要启用 Kapt，请在 gradle 当中启动它：plugin: 'kotlin-kapt'```123456789101112131415161718192021222324252627282930313233## All-open 插件我们知道 Kotlin 的所有类及其成员默认情况下都是 final 的，也就是说你想要继承一个类，就要不断得写各种 open。刚开始看到这一特性的时候，觉得很赞，它对培养良好的编码意识非常有帮助，不过它也在某些情况下给我们带来麻烦，比如在一些大量依赖继承和覆写的 Java 框架的使用中。这一次 Kotlin 提供了一个妥协的办法，主要某个类被某一个特定注解标注，那么这个类就默认所有成员通通 open，省得一个一个写了。有关 allopen 的讨论，大家可以参考这里 [KEEP](https://github.com/Kotlin/KEEP/pull/40)。那么 allopen 如何使用呢？```groovybuildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; &#125;&#125;apply plugin: &quot;kotlin-allopen&quot;allOpen &#123; annotation(&quot;com.your.Annotation&quot;)&#125;buildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-allopen:$kotlin_version&quot; &#125;&#125; apply plugin: &quot;kotlin-allopen&quot; allOpen &#123; annotation(&quot;com.your.Annotation&quot;)&#125; 那么所有被 com.your.Annotation 这个注解标注的类成员都会默认 open。除此之外，它还可以作为元注解使用： 12345@com.your.Annotationannotation class MyFrameworkAnnotation@MyFrameworkAnnotationclass MyClass // will be all-open Kotlin 还提供了 “kotlin-spring” 插件，其中包含了 spring 相关的所有注解，这样免得我们一个一个在 allopen 的配置中声明了。 No-arg 插件如果大家看过我的视频，一定对我之前提到的“毁三观”的实例化有印象吧，附上视频连接：12 Json数据引发的血案，其中我们提到对于没有无参构造方法的 Kotlin 类，Gson 反序列化它们的时候，不知道如何实例化它们，只好用到了 这个类。听说 Java 9 要移除这个略显黑科技的类，如果是这样，Gson 是不是会被削弱呢？Java 的心我们还是不操了，从 Kotlin 1.0.6 开始，这个问题将得到一个比较好的解决。1234567891011121314```groovybuildscript &#123; dependencies &#123; classpath &quot;org.jetbrains.kotlin:kotlin-noarg:$kotlin_version&quot; &#125;&#125;// Or &quot;kotlin-jpa&quot; for the Java Persistence API supportapply plugin: &quot;kotlin-noarg&quot;noArg &#123; annotation(&quot;com.your.Annotation&quot;)&#125; 类似于 allopen 的使用方法，如果某个类需要无参默认构造方法，你只需要用上面声明好的注解 com.your.Annotation 标注即可。当然，这个生成的默认构造方法只能通过反射调用。 如何更新我一直觉得虽然我们出生就被选择了 Hard 模式，但我们没啥感觉啊。可是最近一直访问国外的网站，感觉真的好困难，宽带换成了电信 100M，下载 Kotlin 的插件仍然跟小水管一样，真也是没谁了。为了方便大家我把我下载的几个版本的插件放到百度网盘，供大家使用，请大家点击阅读原文获取下载地址。 小结目前 Kotlin 1.0.x 的版本更新更侧重于稳定性和易用性，因此语言上的特性基本不会更新，主要集中于 IDE 插件和编译器插件。如果大家期待语言特性的更新，那我们就去关注一下 1.1 吧！","tags":[{"name":"AllOpen","slug":"AllOpen","permalink":"https://kotlinandroid.net/tags/AllOpen/"},{"name":"NoArg","slug":"NoArg","permalink":"https://kotlinandroid.net/tags/NoArg/"},{"name":"Kapt","slug":"Kapt","permalink":"https://kotlinandroid.net/tags/Kapt/"}]},{"title":"[译]Kotlin 1.0 Beta 3 发布啦!","date":"2015-12-07T07:45:00.000Z","path":"2015/12/07/Kotlin 1.0 Beta 3 is Out!/","text":"我们很高兴发布了 Kotlin 1.0 Beta 的另一个更新。我们正在努力完善标准库，抛弃了过时已久的设计结构，同时修复了 bugs，改进性能和为下一个版本作准备。完整的更新历史在 这里 。 最新的 issue 在 这里 。 Library 变更我们努力在 1.0 版本到来之前让标准库变得更加完美。这意味着进行一些尝试，所以会有新的部分被弃用，有新的函数被添加。我们计划在 1.0 版本（或 RC）中对标准库进行一次最后的清理：删除所有已过时和其他遗留的东西。这里我们只关心一个需要注意的变化：现在contains()和其他类似的扩展方法接受集合元素的父类型。 1234567// strs: Collection&lt;String&gt;// ns: String?// cs: CharSequence// i: Intstrs.contains(ns) // accepted nowstrs.contains(cs) // accepted nowstr.contains(i) // ERROR (in fact, a deprecation warning, but will be an error soon) 我们发现以前建议的containsRaw方法比较低效，使用contains()更加合适，同时保证了兼容性。请注意，集合接口本身是完整的，所有这些都是通过扩展功能完成的。请使用Code Cleanup来迁移代码。 语言变化一些需要注意的语言变化，完整列表在这里 。 许多我们以前不推荐的实现现在会报错。请使用Code Cleanup进行迁移。 When 表达式这种代码已被证明是有问题的，所以我们决定弃用它： 1234when &#123; foo.isValid(), foo.isReady() -&gt; process(foo) ...&#125; 许多人倾向于认为条件 foo.isValid(), foo.isReady() 表示 foo.isValid() == true and foo.isReady() == true，而实际上逗号是指 or。解决方法很简单：只需使用 ||: 1234when &#123; foo.isValid() || foo.isReady() -&gt; process(foo) ...&#125; Code Cleanup会自动迁移。 注释一个 bug 已被修复，现在我们可以在注解的参数中使用默认值： 12345annotation class Entry(val value: String) annotation class Example( val entries: Array&lt;Entry&gt; = arrayOf(Entry(\"a\"), Entry(\"b\")) // OK now) 枚举值()最近我们将传统的 Java 的Enum.values()更改为一个属性：Enum.values，但现在我们将回滚这个更改，因为有一个没有注意到的角落：枚举中的常量可能被命名为values，然后便没有办法访问其中的任何一个。我们考虑了不同的方案，最后决定将values改回函数是最干净的。所以，现在不推荐使用values属性，也不推荐使用values()函数。 可见性和作用域我们正在清理和修正小问题的可见性和作用域 companion objects 中允许 protected 成员 子类调用非 @JvmStatic 的 protected 对象将被标记为错误（不支持） 对于 open 属性，私有 setters 现在已被标记为过时 local sealed class 已弃用（从不可用） 重写的 setter 不能降低可见性 枚举类中不再允许存在内部类 lambdas / object literals / local 函数中禁止使用未初始化的变量 Android 扩展我们合并了 IntelliJ IDEA 的主要 Kotlin 插件和 Android 的Kotlin扩展插件。后者现在已经过时了，因为它的功能可以从 Kotlin 插件获取。此外，我们还添加了对 Android productFlavors的支持：现在，来自不同 flavors 的属性可以在不同的包中使用。例如，我们可以在build.gradle文件中存在两种 flavors： 12345678productFlavors &#123; free &#123; versionName \"1.0-free\" &#125; pro &#123; versionName \"1.0-pro\" &#125;&#125; 现在，我们不仅可以在main source set中的布局使用合成属性，还可以在 flavor 布局使用合成属性： 1234567891011121314// Import synthetic properties for the `activity_free.xml` layout in the `free` flavorimport kotlinx.android.synthetic.free.activity_free.versionMarker class FreeActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; ... setContentView(R.layout.activity_free) ... versionMarker.text = \"Free version\" &#125;&#125; 请注意，main source set的所有布局现在位于kotlinx.android.synthetic.main包之下，旧的包命名约定已被弃用。 IDE 中的新功能 Android Extensions 插件已被合并到 Kotlin 插件中，不再需要单独安装 创建新的 Gradle 工程时，添加了 Kotlin 的选项以供选择： 调试器：stacktrace 导航功能现在支持跟踪内联函数的堆栈帧。同时对内联函数的步进调试功能进行了一系列的改进。 添加了三个快速初始化新属性的Quick Fixes： Introduce Variable（Ctrl + Alt + V / Cmd + Alt + V）现在支持结构声明(multi-declarations)： 同时Introduce Variable还能使用于 lambda 或匿名函数中： Beta 3 开始支持在字符串模板中使用 Introduce Variable/Parameter/Property/Function 最后，添加了一个实验功能 —— 在 IDE 中对 Kotlin 脚本文件（.kts）做了基本的支持","tags":[]}]